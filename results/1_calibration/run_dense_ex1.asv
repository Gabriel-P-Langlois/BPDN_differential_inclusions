%% runall script
%   This script runs the first numerical experiment of the paper in full.
%
%   Experiment 1 is a ``calibration" experiment designed to show that the
%   BPDN inclusion algorithm works properly. It is compared here to FISTA.
%
%   We generate a random matrix A with m = 256 rows and n = 512 columns,
%   where each column is generated IID from a m-dimensional centered
%   normal distribution N(O,I). The solution vector xsol is a n-dimensional
%   vector with 100 nonzero entries selected at random. The nonzero entries
%   are sampled from {-1,1} with equal probability. We then generate
%   n-dimensional Gaussian noise E_i IID from N(0,1) so that the signal to
%   noise ratio is 1, i.e., normtwo(E) = normtwo(A*xsol). We then compute 
%   b = A*xsol + E.

% Run from the project directory with
% run ./results/1_calibration/run_dense_ex1.m


%% Initialization
use_mlasso = true;
use_mlinprog = true;
use_fista = true;

% Nb of samples and features
m = 2^8;
n = 2^9;

% Signal-to-noise ratio, value of nonzero coefficients, and
% proportion of nonzero coefficients in the signal.
SNR = 1;
val_nonzero = 1;
prop = 0.05;

% Tolerance levels
tol = 1e-08;
tol_glmnet = 1e-14;
tol_mlasso = 1e-08;
tol_fista = 1e-8;

% Grid of hyperparameters
spacing = -0.01;
maxval = 0.99;
minval = 0.0;


%% Generate data
% Set random seed and generate Gaussian data
rng('default')
[A,b,xsol] = generate_gaussian_data(m,n,SNR,val_nonzero,prop);
%load './../../../LOCAL_DATA/l1_testset_data/spear_inst_1.mat'
%[m,n] = size(A);

% Calculate the smallest hyperparameter for which we have the trivial
% primal solution (zero) and dual solution
t0 = norm(A.'*b,inf);
x0 = zeros(n,1);
p0 = -b/t0;

% Generate desired grid of hyperparameters
t = t0 * (maxval:spacing:minval);
kmax = length(t);


%% Solve BPDN using Algorithm 1, MATLAB's native Lasso solver, and FISTA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Diff. Inclusions: BPDN
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
disp('1. Running the differential inclusions BP...')
tic
[sol_incl_x,sol_incl_p, bpdn_count, bpdn_linsolve] = ...
    BPDN_inclusions_regpath_solver(A,b,p0,t,tol);
time_incl_alg = toc;
disp(['Done. Total time = ', num2str(time_incl_alg), ' seconds.'])
disp(['Total number of NNLS solves: ', num2str(bpdn_count), '.'])
disp(['Total number of linsolve calls: ', num2str(bpdn_linsolve)])
disp(' ')


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Diff. Inclusions: Direct Basis Pursuit Solver
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
disp(' ')
disp('2. Running the differential inclusions Basis Pursuit solver...')
tic
[sol_incl_BP_x, sol_incl_BP_p, bp_count, bp_linsolve] = ...
    BP_inclusions_solver(A,b,p0,tol);
time_incl_BP_alg = toc;
disp(['Done. Total time = ', num2str(time_incl_BP_alg), ' seconds.'])
disp(['Total number of NNLS solves: ', num2str(bp_count), '.'])
disp(['Total number of linsolve calls: ', num2str(bp_linsolve)])
disp(' ')


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Greedy homotopy algorithm via the matroid property
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Note: This computes sol_g_xf and sol_g_eqset such that
%    A*sol_g_xf(sol_g_eqset) = b
disp(' ')
disp('3. Running the greedy algorithm \w thresholding...')
tic
[sol_g_x, sol_g_p, sol_g_b, sol_g_xf, sol_g_eqset] = ...
    greedy_homotopy_threshold(A,b,tol);
time_greedy_alg = toc;
disp(['Running the BP solver using the dual greedy solution' ...
    ' as a warm start...'])
tic
[~,~, warm_nnls_count,warm_linsolve_count] = ...
    BP_inclusions_solver(A,b,sol_g_p(:,end),tol);
time_warm = time_greedy_alg + toc;
disp(['Done. Total time = ', num2str(time_warm), ' seconds.'])
disp(['Total number of NNLS solves: ', num2str(warm_nnls_count)])
disp(['Total number of linsolve calls: ', num2str(warm_linsolve_count)])
disp(' ')


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GLMNET
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
warning('off');
options = glmnetSet;
options.alpha = 1;
options.lambda = t;
options.intr = false;
options.thresh = tol_glmnet;
options.maxit = 10^8;

sol_glmnet_x = zeros(n,kmax); % TODO
sol_glmnet_p = zeros(m,kmax); 

% Run the external GLMNET package with thresh = 1e-4
options.thresh = tol_glmnet;
disp('4. Running GLMNET for the BPDN problem \w Reltol = tol')
tic
fit = glmnet(sqrt(m)*A,sqrt(m)*b, 'gaussian', options);
sol_glmnet_x = fit.beta;
for k=1:1:kmax
    sol_glmnet_p(:,k) = (A*sol_glmnet_x(:,k)-b)/t(k);
end
time_glmnet_alg_1 = toc;
disp(['Done. Total time = ', num2str(time_glmnet_alg_1), ' seconds.'])
disp(' ')


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MATLAB's integrated LASSO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if(use_mlasso)
    sol_mlasso_p = zeros(m,kmax); 
    warning('off');
    
    % Run MATLAB's native lasso solver, flip it, and rescale the dual solution
    disp("5. Running MATLAB's integrated LASSO algorithm for the BPDN problem...")
    tic
    sol_mlasso_x = lasso(sqrt(m)*A,sqrt(m)*b, 'lambda', t, ...
        'Intercept', false, 'RelTol', tol_mlasso);
    sol_mlasso_x = flip(sol_mlasso_x,2);
    for k=1:1:kmax
        sol_mlasso_p(:,k) = (A*sol_mlasso_x(:,k)-b)/t(k);
    end
    time_mlasso_alg = toc;
    disp(['Done. Total time = ', num2str(time_mlasso_alg), ' seconds.'])
    disp(' ')
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MATLAB's native lingprog solver for BP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
if(use_mlinprog)
    tic
    disp("6. Computing the solution to BP using MATLAB's native linprog")
    p_lin = linprog(b,[A,-A].',ones(2*n,1));
    time_linprog = toc;
    disp(['Done. Total time = ', num2str(time_linprog), ' seconds.'])
    disp(' ')
end

%%%%%%%%%%%%%%%%%%%%%%%%%
% FISTA + selection rule
%%%%%%%%%%%%%%%%%%%%%%%%%
if(use_fista)
    sol_fista_x = zeros(n,kmax);
    sol_fista_p = zeros(m,kmax);
    max_iters = 50000;
    min_iters = 100;

    % Compute the L22 norm of the matrix A and tau parameter for FISTA
    disp('Final. Running FISTA algorithm...')
    tic
    L22 = svds(A,1)^2;
    time_fista_L22 = toc;
    
    % Computer some parameters and options for FISTA
    tau = 1/L22;
    
    % Run the FISTA solver and rescale the dual solution
    tic
    
    % k == 1
    [sol_fista_x(:,1),sol_fista_p(:,1),num_iters] = ...
            lasso_fista_solver(x0,p0,t(1),...
            A,b,tau,max_iters,tol_fista,min_iters);
    sol_fista_p(:,1) = sol_fista_p(:,1)/t(1);
    
    % k >= 2
    for k=2:1:kmax
        % Selection rule
        ind = lasso_screening_rule(t(k)/t(k-1),sol_fista_p(:,k-1),A);
    
        % Compute solution
        [sol_fista_x(ind,k),sol_fista_p(:,k),num_iters] = ...
            lasso_fista_solver(sol_fista_x(ind,k-1),sol_fista_p(:,k-1),t(k),...
            A(:,ind),b,tau,max_iters,tol_fista,min_iters);
        sol_fista_p(:,k) = sol_fista_p(:,k)/t(k);
    end
    time_fista_alg = toc;
    time_fista_total = time_fista_alg + time_fista_L22;
    disp(['Done. Total time = ', num2str(time_fista_total), ' seconds.'])
    disp(' ')
end


% Set summarize flag to true
summarize_1_calibration = true;