%% Script for solving the Lasso problem with random data.
% Exact procedure as outlined in GPL's notes + Tendero et al. (2021)

%% NOTES
% The time interval is lambda0-lambda1, which is NOT delta t. Careful!!

%% Data acquisition
m = 250; n = 5000;
prop = 0.05;    % Proportion of coefficients that are equal to 10.
SNR = 5;

% Design matrix + Normalize it
rng('default')
A = randn(m,n);
A = A./sqrt(sum(A.^2)/m);

xsol = zeros(n,1);
xsol(randsample(n,n*prop)) = 10; 
ind_xsol = find(xsol);
sigma = norm(A*xsol)/sqrt(SNR);

b = (A*xsol + sqrt(sigma)*randn(m,1));
tol = 1e-10;
tol_minus = 1-tol;


%% Initialization for differential inclusion method
disp(' ')
disp('Method: Lasso via differential inclusions')
tic

% Redefine the matrix A and compute -b and -b.'.
A = [A,-A];
minusb = -b; 
minusb_t = minusb.';

mv_term1 = (minusb_t*A).';
t = norm(mv_term1,inf); 

p = minusb/t;                % Initial dual solution
mv_term1 = mv_term1/t;       % -A.'*b/norminf

tmp1 = zeros(m,1);
mv_term2 = zeros(2*n,1);

% Active set information
current_set = (mv_term1 >= tol_minus);
current_ids = find(current_set);
current_n = sum(current_set);


%% Initiate active matrix
K = A(:,current_set);
[Q,R] = qr(K);

% Placeholders
direction = zeros(m);

% Naive approach to storing the regularization path
max_iter = m;
regpath = zeros(min(max_iter,m)+1,1); regpath(1) = t;
solpath = zeros(n,min(max_iter,m)+1); solpath(:,1) = zeros(n,1);

% Parameters for the algorithms
shall_continue = true;
nb_iterations = 0;


%% Solution via differential inclusion
while ((shall_continue && (nb_iterations < max_iter)))
    nb_iterations = nb_iterations + 1;

    %%% 1. Compute direction
    x_nnls = R(1:current_n,:)\((minusb_t*Q(:,1:current_n)).');
    tmp1 = K*x_nnls;
    direction = minusb - tmp1;
    
    % Store current solution
    tmp = zeros(2*n,1); tmp(current_set) = x_nnls;
    solpath(:,nb_iterations+1) = -tmp(1:end/2) + tmp(end/2+1:end);

    %%% 2. Compute S_CË†+(lambda) set
    mv_term2 = A.'*direction;
    active_set_plus = (mv_term2 > tol);
    
    % Verify if active_set_plus is empty. Stop if it is, else continue.
    if (any(active_set_plus))
        vec = (1-mv_term1)./mv_term2;
        timestep = min(vec(active_set_plus));
        % Safety check: t must be non-negative.
        if (timestep < 0) 
            t = 0;
            break;
        end
    else % Stop; termination condition satisfied.
        t = 0;
        break
    end

    %%% 3. Update variables and proceed to the next iteration
    factor1 = 1/(1+timestep*t);
    factor2 = timestep;
    p = factor1*p + factor2*direction;
    mv_term1 = factor1*mv_term1 + factor2*mv_term2;

    t = t/(1+t*timestep); 
    regpath(nb_iterations + 1) = t;

    disp(

    %%% 4. Compute new active set and indices

    current_set = (mv_term1 >= tol_minus);
    new_ids = find(current_set);
    new_n = sum(current_set);

    % Update active matrix
    K = [A(:,current_set(1:n)),-A(:,current_set(n+1:end))]; % SLOW
    
    % Update QR matrix if only one active element has changed.
    if(new_n-current_n == 1)
        % Append a row
        [~,pos] = setdiff(new_ids,current_ids);
        
        R(:,pos+1:current_n+1) = R(:,pos:current_n);
        R(:,pos) = (K(:,pos).'*Q).';
        [Q,R] = matlab.internal.math.insertCol(Q,R,pos);
    else
        % More than one active vector is added or removed,
        % so perform the QR decomposition in full.
        [Q,R] = qr(K);
    end

    % Update indices for the next iteration
    current_n = new_n;
    current_ids = new_ids;
end
A = A(:,1:n);
time_bp_alg = toc;
disp('Complete!')
disp(['Time for the homotopy algorithm: ',num2str(time_bp_alg)])
disp(['Residual norm (non-squared): ',num2str(norm(A*solpath(:,end)-b))])


%% GLMNET
disp(' ')
disp('Method 2: Using GLMNET')   
tic
opts = struct('lambda',regpath,'alpha',1,'intr',false,'standardize',false);
fit=glmnet(sqrt(m)*A,sqrt(m)*b,'gaussian',opts);
time_glmnet = toc;
disp('Complete!')
disp(['Time for GLMNET: ',num2str(time_glmnet)])

coeffs = glmnetPredict(fit,sqrt(m)*A,regpath(end),'coefficients');
coeffs(1) = [];


%% nPDHG method


%% Diagnostic
disp(['Residual norm (non-squared) with differential inclusions: ',num2str(norm(A*solpath(:,end)-b))])
disp(['Residual norm (non-squared) with GLMNET: ',num2str(norm(A*coeffs-b))])
disp(norm(coeffs-solpath(:,end))/norm(solpath(:,end)))
